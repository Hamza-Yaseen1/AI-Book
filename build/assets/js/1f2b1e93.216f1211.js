"use strict";(globalThis.webpackChunkphysical_ai=globalThis.webpackChunkphysical_ai||[]).push([[7252],{1856:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"chapter-2/lesson-2","title":"Lesson 2: Advanced Control Systems and Feedback Loops","description":"Learning Objectives","source":"@site/docs/chapter-2/lesson-2.md","sourceDirName":"chapter-2","slug":"/chapter-2/lesson-2","permalink":"/docs/chapter-2/lesson-2","draft":false,"unlisted":false,"editUrl":"https://github.com/hamza-11/physical-ai/tree/main/docs/chapter-2/lesson-2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 1: Multi-Sensor Fusion and Data Integration","permalink":"/docs/chapter-2/lesson-1"},"next":{"title":"Lesson 3: Collaborative and Networked Physical AI","permalink":"/docs/chapter-2/lesson-3"}}');var r=n(4848),i=n(8453);const o={sidebar_position:2},l="Lesson 2: Advanced Control Systems and Feedback Loops",a={},p=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction to Control Systems",id:"introduction-to-control-systems",level:2},{value:"Types of Control Systems",id:"types-of-control-systems",level:3},{value:"PID Controller Theory",id:"pid-controller-theory",level:2},{value:"PID Equation",id:"pid-equation",level:3},{value:"The Three Terms",id:"the-three-terms",level:3},{value:"PID Controller Implementation",id:"pid-controller-implementation",level:2},{value:"Practical Example: Temperature Control System",id:"practical-example-temperature-control-system",level:2},{value:"PID Tuning Methods",id:"pid-tuning-methods",level:2},{value:"1. Ziegler-Nichols Method",id:"1-ziegler-nichols-method",level:3},{value:"2. Trial and Error",id:"2-trial-and-error",level:3},{value:"3. Software-based Tuning",id:"3-software-based-tuning",level:3},{value:"Safety Considerations in Control Systems",id:"safety-considerations-in-control-systems",level:2},{value:"1. Limits and Constraints",id:"1-limits-and-constraints",level:3},{value:"2. Fail-Safe Mechanisms",id:"2-fail-safe-mechanisms",level:3},{value:"3. Monitoring and Logging",id:"3-monitoring-and-logging",level:3},{value:"Practical Project: Motor Speed Control",id:"practical-project-motor-speed-control",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"lesson-2-advanced-control-systems-and-feedback-loops",children:"Lesson 2: Advanced Control Systems and Feedback Loops"})}),"\n",(0,r.jsx)(t.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Understand PID (Proportional-Integral-Derivative) control principles"}),"\n",(0,r.jsx)(t.li,{children:"Implement PID controllers for Physical AI systems"}),"\n",(0,r.jsx)(t.li,{children:"Tune PID parameters for optimal system performance"}),"\n",(0,r.jsx)(t.li,{children:"Apply control theory to real physical systems"}),"\n",(0,r.jsx)(t.li,{children:"Implement safety mechanisms in control systems"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(t.p,{children:"Before starting this lesson, you should:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Have completed Chapter 1 and Lesson 1 of Chapter 2"}),"\n",(0,r.jsx)(t.li,{children:"Understand basic sensor reading and data processing concepts"}),"\n",(0,r.jsx)(t.li,{children:"Be familiar with Python programming"}),"\n",(0,r.jsx)(t.li,{children:"Have basic understanding of feedback concepts from Lesson 1"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"introduction-to-control-systems",children:"Introduction to Control Systems"}),"\n",(0,r.jsx)(t.p,{children:"Control systems are fundamental to Physical AI, allowing systems to respond appropriately to sensor inputs and maintain desired behaviors. A control system continuously measures the output of a process and adjusts the input to achieve a desired outcome."}),"\n",(0,r.jsx)(t.h3,{id:"types-of-control-systems",children:"Types of Control Systems"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Open-loop Control"}),": Control action is independent of output"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Closed-loop Control (Feedback)"}),": Control action depends on output measurement"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Feedforward Control"}),": Anticipates disturbances before they affect the system"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"pid-controller-theory",children:"PID Controller Theory"}),"\n",(0,r.jsx)(t.p,{children:"The PID (Proportional-Integral-Derivative) controller is the most common feedback controller. It calculates an error value as the difference between a desired setpoint and a measured process variable, then applies a correction based on proportional, integral, and derivative terms."}),"\n",(0,r.jsx)(t.h3,{id:"pid-equation",children:"PID Equation"}),"\n",(0,r.jsx)(t.p,{children:"The PID controller output is calculated as:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"u(t) = Kp * e(t) + Ki * \u222be(t)dt + Kd * de(t)/dt\n"})}),"\n",(0,r.jsx)(t.p,{children:"Where:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"u(t)"})," is the controller output"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"e(t)"})," is the error (setpoint - process variable)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Kp"}),", ",(0,r.jsx)(t.code,{children:"Ki"}),", ",(0,r.jsx)(t.code,{children:"Kd"})," are the proportional, integral, and derivative gains"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"the-three-terms",children:"The Three Terms"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Proportional (P)"}),": Reduces current error, but may have steady-state error"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Integral (I)"}),": Eliminates steady-state error by considering past errors"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Derivative (D)"}),": Predicts future error based on current rate of change"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"pid-controller-implementation",children:"PID Controller Implementation"}),"\n",(0,r.jsx)(t.p,{children:"Let's implement a basic PID controller:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'class PIDController:\n    def __init__(self, kp, ki, kd, setpoint=0):\n        """\n        Initialize PID controller\n\n        Args:\n            kp: Proportional gain\n            ki: Integral gain\n            kd: Derivative gain\n            setpoint: Desired value\n        """\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n        self.setpoint = setpoint\n\n        # Internal variables\n        self.previous_error = 0\n        self.integral = 0\n        self.derivative = 0\n\n    def compute(self, current_value, dt=1.0):\n        """\n        Compute PID output\n\n        Args:\n            current_value: Current measured value\n            dt: Time step (for derivative calculation)\n\n        Returns:\n            Control output\n        """\n        # Calculate error\n        error = self.setpoint - current_value\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term (with anti-windup protection)\n        self.integral += error * dt\n        # Limit integral term to prevent windup\n        self.integral = max(min(self.integral, 100), -100)\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        if dt > 0:\n            self.derivative = (error - self.previous_error) / dt\n        else:\n            self.derivative = 0\n        d_term = self.kd * self.derivative\n\n        # Calculate output\n        output = p_term + i_term + d_term\n\n        # Store error for next iteration\n        self.previous_error = error\n\n        return output\n\n    def set_setpoint(self, setpoint):\n        """Update the setpoint"""\n        self.setpoint = setpoint\n        # Reset integral when setpoint changes significantly\n        if abs(setpoint - self.setpoint) > 1:\n            self.integral = 0\n\n    def set_tunings(self, kp, ki, kd):\n        """Update PID tunings"""\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n'})}),"\n",(0,r.jsx)(t.h2,{id:"practical-example-temperature-control-system",children:"Practical Example: Temperature Control System"}),"\n",(0,r.jsx)(t.p,{children:"Let's implement a complete temperature control system using PID:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'import time\nimport matplotlib.pyplot as plt\nimport random\n\nclass TemperatureControlSystem:\n    def __init__(self, initial_temp=20.0):\n        # Initialize PID controller for temperature control\n        self.pid = PIDController(kp=2.0, ki=0.1, kd=0.05, setpoint=25.0)  # Target: 25\xb0C\n        self.current_temp = initial_temp\n        self.heat_output = 0  # Output to heating element (0-100%)\n\n        # System characteristics\n        self.thermal_mass = 5.0  # How slowly temperature changes\n        self.heat_loss_rate = 0.1  # Rate of heat loss to environment\n\n    def update(self, dt=0.1):\n        """\n        Update the temperature control system\n\n        Args:\n            dt: Time step in seconds\n        """\n        # Get PID output based on current temperature\n        control_signal = self.pid.compute(self.current_temp, dt)\n\n        # Apply limits to heating output (0-100%)\n        self.heat_output = max(0, min(100, control_signal))\n\n        # Simulate temperature change based on heating and cooling\n        heating_effect = (self.heat_output / 100.0) * 2.0 * dt  # Heat added\n        cooling_effect = (self.current_temp - 20.0) * self.heat_loss_rate * dt  # Heat lost\n\n        # Update temperature with some noise to simulate real system\n        temp_change = heating_effect - cooling_effect + random.uniform(-0.1, 0.1) * dt\n        self.current_temp += temp_change / self.thermal_mass\n\n        return self.current_temp, self.heat_output\n\ndef run_temperature_control():\n    """Run the temperature control simulation"""\n    system = TemperatureControlSystem(initial_temp=20.0)\n\n    # Data storage for plotting\n    times = []\n    temperatures = []\n    heat_outputs = []\n    setpoints = []\n\n    print("Temperature Control System Simulation")\n    print("=====================================")\n    print("Target temperature: 25\xb0C")\n    print("Initial temperature: 20\xb0C")\n    print("\\nTime(s)\\tTemp(\xb0C)\\tHeat(%)\\tError")\n    print("-" * 40)\n\n    start_time = time.time()\n\n    for i in range(200):  # Run for 200 steps (20 seconds at 0.1s intervals)\n        current_time = i * 0.1\n        temp, heat_output = system.update(dt=0.1)\n\n        # Calculate error\n        error = abs(system.pid.setpoint - temp)\n\n        # Print status every 10 steps\n        if i % 10 == 0:\n            print(f"{current_time:5.1f}\\t{temp:6.2f}\\t{heat_output:6.2f}\\t{error:6.2f}")\n\n        # Store data for plotting\n        times.append(current_time)\n        temperatures.append(temp)\n        heat_outputs.append(heat_output)\n        setpoints.append(system.pid.setpoint)\n\n        time.sleep(0.01)  # Small delay to simulate real-time operation\n\n    # Plot results\n    plt.figure(figsize=(12, 8))\n\n    plt.subplot(2, 1, 1)\n    plt.plot(times, temperatures, label=\'Actual Temperature\', linewidth=2)\n    plt.plot(times, setpoints, label=\'Setpoint\', linestyle=\'--\', linewidth=2)\n    plt.xlabel(\'Time (s)\')\n    plt.ylabel(\'Temperature (\xb0C)\')\n    plt.title(\'Temperature Control System Response\')\n    plt.legend()\n    plt.grid(True)\n\n    plt.subplot(2, 1, 2)\n    plt.plot(times, heat_outputs, label=\'Heat Output\', color=\'red\', linewidth=2)\n    plt.xlabel(\'Time (s)\')\n    plt.ylabel(\'Heat Output (%)\')\n    plt.title(\'Heating Element Output\')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n    final_error = abs(system.pid.setpoint - system.current_temp)\n    print(f"\\nFinal temperature: {system.current_temp:.2f}\xb0C")\n    print(f"Final error: {final_error:.2f}\xb0C")\n    print(f"Steady-state error: {final_error:.2f}\xb0C")\n\n# Run the simulation\nif __name__ == "__main__":\n    run_temperature_control()\n'})}),"\n",(0,r.jsx)(t.h2,{id:"pid-tuning-methods",children:"PID Tuning Methods"}),"\n",(0,r.jsx)(t.p,{children:"Properly tuning PID parameters is crucial for system performance. Here are common tuning methods:"}),"\n",(0,r.jsx)(t.h3,{id:"1-ziegler-nichols-method",children:"1. Ziegler-Nichols Method"}),"\n",(0,r.jsx)(t.p,{children:"This method involves finding the ultimate gain (Ku) and ultimate period (Pu) where the system oscillates with constant amplitude."}),"\n",(0,r.jsx)(t.h3,{id:"2-trial-and-error",children:"2. Trial and Error"}),"\n",(0,r.jsx)(t.p,{children:"Start with conservative values and adjust based on system response:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Start with P only, increase until oscillation occurs"}),"\n",(0,r.jsx)(t.li,{children:"Add I to eliminate steady-state error"}),"\n",(0,r.jsx)(t.li,{children:"Add D to reduce overshoot"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"3-software-based-tuning",children:"3. Software-based Tuning"}),"\n",(0,r.jsx)(t.p,{children:"Use automated tools to find optimal parameters based on system response."}),"\n",(0,r.jsx)(t.h2,{id:"safety-considerations-in-control-systems",children:"Safety Considerations in Control Systems"}),"\n",(0,r.jsx)(t.p,{children:"When implementing control systems, especially for physical systems, safety is paramount:"}),"\n",(0,r.jsx)(t.h3,{id:"1-limits-and-constraints",children:"1. Limits and Constraints"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Set output limits to prevent damage"}),"\n",(0,r.jsx)(t.li,{children:"Implement rate limiting to prevent sudden changes"}),"\n",(0,r.jsx)(t.li,{children:"Use position and velocity limits for mechanical systems"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"2-fail-safe-mechanisms",children:"2. Fail-Safe Mechanisms"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Default to safe state if sensors fail"}),"\n",(0,r.jsx)(t.li,{children:"Implement watchdog timers"}),"\n",(0,r.jsx)(t.li,{children:"Use redundant sensors for critical systems"}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"3-monitoring-and-logging",children:"3. Monitoring and Logging"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Log all control actions for debugging"}),"\n",(0,r.jsx)(t.li,{children:"Monitor system health continuously"}),"\n",(0,r.jsx)(t.li,{children:"Alert when parameters exceed safe ranges"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"practical-project-motor-speed-control",children:"Practical Project: Motor Speed Control"}),"\n",(0,r.jsx)(t.p,{children:"Let's create a practical project implementing PID control for motor speed:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'# physical-ai/static/examples/chapter-2/lesson-2-motor-control.py\nimport time\nimport random\nimport matplotlib.pyplot as plt\n\nclass MotorControlSystem:\n    def __init__(self, initial_speed=0):\n        # Initialize PID controller for motor speed control\n        self.pid = PIDController(kp=1.5, ki=0.2, kd=0.01, setpoint=100)  # Target: 100 RPM\n        self.current_speed = initial_speed\n        self.motor_output = 0  # Motor output (0-100%)\n\n        # Motor characteristics\n        self.motor_inertia = 3.0  # How slowly speed changes\n        self.friction = 0.05  # Friction losses\n\n        # Safety limits\n        self.max_speed = 200  # Maximum RPM\n        self.max_output = 100  # Maximum output percentage\n\n    def update(self, dt=0.05):\n        """\n        Update the motor control system\n\n        Args:\n            dt: Time step in seconds\n        """\n        # Get PID output based on current speed\n        control_signal = self.pid.compute(self.current_speed, dt)\n\n        # Apply limits to motor output\n        self.motor_output = max(0, min(self.max_output, control_signal))\n\n        # Simulate motor response with some delay and friction\n        target_change = (self.motor_output / 100.0) * 50.0 * dt  # Max 50 RPM change per second\n        friction_loss = self.current_speed * self.friction * dt\n\n        # Apply changes with motor inertia\n        speed_change = (target_change - friction_loss) / self.motor_inertia\n        self.current_speed += speed_change\n\n        # Apply limits\n        self.current_speed = max(0, min(self.max_speed, self.current_speed))\n\n        # Add some noise to simulate real motor\n        self.current_speed += random.uniform(-0.5, 0.5) * dt\n\n        return self.current_speed, self.motor_output\n\n    def emergency_stop(self):\n        """Emergency stop function"""\n        self.pid.set_setpoint(0)\n        self.motor_output = 0\n        print("Emergency stop activated!")\n\ndef run_motor_control():\n    """Run the motor control simulation"""\n    system = MotorControlSystem(initial_speed=0)\n\n    # Data storage for plotting\n    times = []\n    speeds = []\n    outputs = []\n    setpoints = []\n\n    print("Motor Speed Control System Simulation")\n    print("=====================================")\n    print("Target speed: 100 RPM")\n    print("Initial speed: 0 RPM")\n    print("\\nTime(s)\\tSpeed(RPM)\\tOutput(%)\\tError")\n    print("-" * 45)\n\n    # Change setpoint during simulation to test response\n    setpoint_changes = [(50, 2.0), (150, 6.0), (100, 10.0)]  # (setpoint, time)\n\n    start_time = time.time()\n\n    for i in range(200):  # Run for 200 steps (10 seconds at 0.05s intervals)\n        current_time = i * 0.05\n\n        # Check for setpoint changes\n        for new_setpoint, change_time in setpoint_changes:\n            if abs(current_time - change_time) < 0.05:  # Within time threshold\n                system.pid.set_setpoint(new_setpoint)\n                print(f"Setpoint changed to {new_setpoint} RPM at {current_time:.2f}s")\n\n        speed, output = system.update(dt=0.05)\n\n        # Calculate error\n        error = abs(system.pid.setpoint - speed)\n\n        # Print status every 20 steps\n        if i % 20 == 0:\n            print(f"{current_time:5.2f}\\t{speed:8.2f}\\t{output:8.2f}\\t{error:6.2f}")\n\n        # Store data for plotting\n        times.append(current_time)\n        speeds.append(speed)\n        outputs.append(output)\n        setpoints.append(system.pid.setpoint)\n\n        time.sleep(0.001)  # Small delay\n\n    # Plot results\n    plt.figure(figsize=(12, 8))\n\n    plt.subplot(2, 1, 1)\n    plt.plot(times, speeds, label=\'Actual Speed\', linewidth=2)\n    plt.plot(times, setpoints, label=\'Setpoint\', linestyle=\'--\', linewidth=2)\n    plt.xlabel(\'Time (s)\')\n    plt.ylabel(\'Speed (RPM)\')\n    plt.title(\'Motor Speed Control System Response\')\n    plt.legend()\n    plt.grid(True)\n\n    plt.subplot(2, 1, 2)\n    plt.plot(times, outputs, label=\'Motor Output\', color=\'red\', linewidth=2)\n    plt.xlabel(\'Time (s)\')\n    plt.ylabel(\'Motor Output (%)\')\n    plt.title(\'Motor Output Signal\')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n    final_error = abs(system.pid.setpoint - system.current_speed)\n    print(f"\\nFinal speed: {system.current_speed:.2f} RPM")\n    print(f"Final error: {final_error:.2f} RPM")\n    print(f"System stability: {\'Good\' if final_error < 5 else \'Needs tuning\'}")\n\nif __name__ == "__main__":\n    run_motor_control()\n'})}),"\n",(0,r.jsx)(t.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Temperature Control Tuning"}),": Implement different PID tuning methods and compare their performance"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Cascade Control"}),": Create a cascade control system with inner and outer loops"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Adaptive PID"}),": Implement a PID controller that adjusts its parameters based on system conditions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Multi-Variable Control"}),": Extend the system to control multiple variables simultaneously"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"In this lesson, we explored advanced control systems, focusing on PID controllers. We implemented a complete temperature control system and motor speed control project, demonstrating how PID controllers can be used to maintain desired system behaviors."}),"\n",(0,r.jsx)(t.p,{children:"Control systems are essential for Physical AI applications, providing the feedback mechanisms needed to respond to environmental changes and maintain desired states. Proper tuning and safety considerations are crucial for reliable operation."}),"\n",(0,r.jsx)(t.p,{children:"In the next lesson, we'll explore networked Physical AI systems that can communicate and coordinate with each other."})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var s=n(6540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);