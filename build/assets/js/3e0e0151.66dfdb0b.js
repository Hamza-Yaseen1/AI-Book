"use strict";(globalThis.webpackChunkphysical_ai=globalThis.webpackChunkphysical_ai||[]).push([[9861],{1165:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>f,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"chapter-2/lesson-3","title":"Lesson 3: Collaborative and Networked Physical AI","description":"Learning Objectives","source":"@site/docs/chapter-2/lesson-3.md","sourceDirName":"chapter-2","slug":"/chapter-2/lesson-3","permalink":"/docs/chapter-2/lesson-3","draft":false,"unlisted":false,"editUrl":"https://github.com/hamza-11/physical-ai/tree/main/docs/chapter-2/lesson-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 2: Advanced Control Systems and Feedback Loops","permalink":"/docs/chapter-2/lesson-2"},"next":{"title":"Lesson 1: ML in Physical Systems","permalink":"/docs/ch03-ml-physical-ai/ch03-lesson01/"}}');var s=t(4848),o=t(8453);const r={sidebar_position:3},a="Lesson 3: Collaborative and Networked Physical AI",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction to Networked Physical AI",id:"introduction-to-networked-physical-ai",level:2},{value:"Communication Protocols for Physical AI",id:"communication-protocols-for-physical-ai",level:2},{value:"MQTT (Message Queuing Telemetry Transport)",id:"mqtt-message-queuing-telemetry-transport",level:3},{value:"Key Features:",id:"key-features",level:4},{value:"Other Protocols",id:"other-protocols",level:3},{value:"MQTT Implementation for Physical AI",id:"mqtt-implementation-for-physical-ai",level:2},{value:"Practical Project: Networked Sensor Network",id:"practical-project-networked-sensor-network",level:2},{value:"Network Fallback and Redundancy",id:"network-fallback-and-redundancy",level:2},{value:"Safety Considerations for Networked AI",id:"safety-considerations-for-networked-ai",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"lesson-3-collaborative-and-networked-physical-ai",children:"Lesson 3: Collaborative and Networked Physical AI"})}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand communication protocols for Physical AI systems"}),"\n",(0,s.jsx)(n.li,{children:"Implement MQTT for device-to-device communication"}),"\n",(0,s.jsx)(n.li,{children:"Create networked Physical AI systems that coordinate actions"}),"\n",(0,s.jsx)(n.li,{children:"Handle network failures and implement redundancy"}),"\n",(0,s.jsx)(n.li,{children:"Design distributed intelligence systems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"Before starting this lesson, you should:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Have completed Chapter 1 and Lessons 1-2 of Chapter 2"}),"\n",(0,s.jsx)(n.li,{children:"Understand basic networking concepts"}),"\n",(0,s.jsx)(n.li,{children:"Be familiar with Python networking libraries"}),"\n",(0,s.jsx)(n.li,{children:"Understand system state and coordination concepts"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction-to-networked-physical-ai",children:"Introduction to Networked Physical AI"}),"\n",(0,s.jsx)(n.p,{children:"Modern Physical AI systems often need to communicate with other systems or cloud services, making networking capabilities essential for real-world applications. Networked Physical AI enables:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Distributed Intelligence"}),": Multiple systems working together to solve complex problems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Sharing"}),": Sharing sensors, actuators, or computational resources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Remote Monitoring"}),": Supervising and controlling systems from a distance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Coordinated Actions"}),": Multiple systems working together towards a common goal"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"communication-protocols-for-physical-ai",children:"Communication Protocols for Physical AI"}),"\n",(0,s.jsx)(n.h3,{id:"mqtt-message-queuing-telemetry-transport",children:"MQTT (Message Queuing Telemetry Transport)"}),"\n",(0,s.jsx)(n.p,{children:"MQTT is a lightweight messaging protocol designed for IoT and Physical AI applications. It uses a publish-subscribe pattern that makes it ideal for distributed Physical AI systems."}),"\n",(0,s.jsx)(n.h4,{id:"key-features",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lightweight and efficient"}),"\n",(0,s.jsx)(n.li,{children:"Designed for unreliable networks"}),"\n",(0,s.jsx)(n.li,{children:"Supports Quality of Service (QoS) levels"}),"\n",(0,s.jsx)(n.li,{children:'Built-in support for "last will" messages'}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"other-protocols",children:"Other Protocols"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"HTTP/REST"}),": Universal but not optimized for real-time Physical AI"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"WebSocket"}),": Bi-directional communication but more resource-intensive"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CoAP"}),": Constrained Application Protocol for resource-limited devices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Custom TCP/UDP"}),": For specific performance requirements"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"mqtt-implementation-for-physical-ai",children:"MQTT Implementation for Physical AI"}),"\n",(0,s.jsx)(n.p,{children:"Let's implement a basic MQTT publisher and subscriber for Physical AI systems:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\nimport time\nimport threading\nimport random\nfrom datetime import datetime\n\nclass PhysicalAIPublisher:\n    """\n    A Physical AI system that publishes sensor data and status updates\n    """\n    def __init__(self, client_id, broker="localhost", port=1883):\n        self.client = mqtt.Client(client_id)\n        self.client.on_connect = self.on_connect\n        self.client.on_disconnect = self.on_disconnect\n        self.client.on_publish = self.on_publish\n\n        self.broker = broker\n        self.port = port\n        self.connected = False\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            print(f"Publisher {client._client_id.decode()} connected to MQTT broker")\n            self.connected = True\n        else:\n            print(f"Failed to connect, return code {rc}")\n            self.connected = False\n\n    def on_disconnect(self, client, userdata, rc):\n        print(f"Publisher {client._client_id.decode()} disconnected from MQTT broker")\n        self.connected = False\n\n    def on_publish(self, client, userdata, mid):\n        pass  # Successfully published\n\n    def connect(self):\n        """Connect to the MQTT broker"""\n        try:\n            self.client.connect(self.broker, self.port, 60)\n            self.client.loop_start()\n            # Wait for connection\n            timeout = 5  # 5 seconds timeout\n            start_time = time.time()\n            while not self.connected and time.time() - start_time < timeout:\n                time.sleep(0.1)\n            return self.connected\n        except Exception as e:\n            print(f"Error connecting to MQTT broker: {e}")\n            return False\n\n    def publish_sensor_data(self, sensor_type, value, additional_data=None):\n        """\n        Publish sensor data to MQTT topic\n\n        Args:\n            sensor_type: Type of sensor (e.g., \'temperature\', \'motion\')\n            value: Sensor reading value\n            additional_data: Additional data to include in message\n        """\n        if not self.connected:\n            print("Cannot publish: not connected to broker")\n            return\n\n        data = {\n            "sensor_type": sensor_type,\n            "value": value,\n            "timestamp": datetime.now().isoformat(),\n            "device_id": self.client._client_id.decode(),\n            "additional_data": additional_data or {}\n        }\n\n        topic = f"physical_ai/{sensor_type}"\n        self.client.publish(topic, json.dumps(data))\n        print(f"Published to {topic}: {data}")\n\n    def publish_status(self, status, message=""):\n        """Publish device status"""\n        if not self.connected:\n            return\n\n        data = {\n            "status": status,\n            "message": message,\n            "timestamp": datetime.now().isoformat(),\n            "device_id": self.client._client_id.decode()\n        }\n\n        topic = f"physical_ai/status"\n        self.client.publish(topic, json.dumps(data))\n        print(f"Published status: {data}")\n\nclass PhysicalAISubscriber:\n    """\n    A Physical AI system that subscribes to sensor data and coordinates actions\n    """\n    def __init__(self, client_id, broker="localhost", port=1883):\n        self.client = mqtt.Client(client_id)\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_disconnect = self.on_disconnect\n\n        self.broker = broker\n        self.port = port\n        self.connected = False\n        self.received_messages = []\n        self.subscribed_topics = []\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            print(f"Subscriber {client._client_id.decode()} connected to MQTT broker")\n            self.connected = True\n            # Subscribe to topics after connection\n            for topic in self.subscribed_topics:\n                client.subscribe(topic)\n        else:\n            print(f"Failed to connect, return code {rc}")\n            self.connected = False\n\n    def on_message(self, client, userdata, msg):\n        """Handle incoming messages"""\n        try:\n            data = json.loads(msg.payload.decode())\n            print(f"Received from {msg.topic}: {data}")\n\n            # Store received message\n            self.received_messages.append({\n                "topic": msg.topic,\n                "data": data,\n                "timestamp": time.time()\n            })\n\n            # Process the sensor data\n            self.process_sensor_data(data)\n        except json.JSONDecodeError:\n            print(f"Received non-JSON message: {msg.payload.decode()}")\n\n    def on_disconnect(self, client, userdata, rc):\n        print(f"Subscriber {client._client_id.decode()} disconnected from MQTT broker")\n        self.connected = False\n\n    def process_sensor_data(self, data):\n        """\n        Process incoming sensor data and take appropriate action\n\n        Args:\n            data: Dictionary containing sensor data\n        """\n        sensor_type = data.get("sensor_type")\n        value = data.get("value")\n\n        # Example processing logic\n        if sensor_type == "temperature" and value is not None:\n            if value > 25:\n                print(f"  -> Action: Temperature too high ({value}\xb0C) - triggering cooling!")\n            elif value < 18:\n                print(f"  -> Action: Temperature too low ({value}\xb0C) - triggering heating!")\n\n        elif sensor_type == "motion" and value is not None:\n            if value == 1:  # Motion detected\n                print(f"  -> Action: Motion detected - increasing monitoring!")\n\n    def connect(self):\n        """Connect to the MQTT broker"""\n        try:\n            self.client.connect(self.broker, self.port, 60)\n            self.client.loop_start()\n            # Wait for connection\n            timeout = 5  # 5 seconds timeout\n            start_time = time.time()\n            while not self.connected and time.time() - start_time < timeout:\n                time.sleep(0.1)\n            return self.connected\n        except Exception as e:\n            print(f"Error connecting to MQTT broker: {e}")\n            return False\n\n    def subscribe_to_topic(self, topic):\n        """Subscribe to a specific topic"""\n        if self.connected:\n            self.client.subscribe(topic)\n        else:\n            # Store for subscription after connection\n            self.subscribed_topics.append(topic)\n\n    def get_recent_messages(self, topic_filter=None, max_age_seconds=30):\n        """\n        Get recent messages\n\n        Args:\n            topic_filter: Filter by topic (None for all topics)\n            max_age_seconds: Maximum age of messages to return\n\n        Returns:\n            List of recent messages\n        """\n        current_time = time.time()\n        recent_msgs = []\n\n        for msg in self.received_messages:\n            if current_time - msg["timestamp"] <= max_age_seconds:\n                if topic_filter is None or topic_filter in msg["topic"]:\n                    recent_msgs.append(msg)\n\n        return recent_msgs\n'})}),"\n",(0,s.jsx)(n.h2,{id:"practical-project-networked-sensor-network",children:"Practical Project: Networked Sensor Network"}),"\n",(0,s.jsx)(n.p,{children:"Let's create a practical project that demonstrates multiple Physical AI systems communicating and coordinating:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# physical-ai/static/examples/chapter-2/lesson-3-networked-project.py\nimport paho.mqtt.client as mqtt\nimport json\nimport time\nimport threading\nimport random\nfrom datetime import datetime\n\nclass NetworkedPhysicalAI:\n    """\n    A networked Physical AI system that can both publish and subscribe\n    """\n    def __init__(self, device_id, broker="localhost", port=1883):\n        self.device_id = device_id\n        self.client = mqtt.Client(device_id)\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self.client.on_disconnect = self.on_disconnect\n\n        self.broker = broker\n        self.port = port\n        self.connected = False\n        self.received_messages = []\n\n        # Device state\n        self.local_sensors = {\n            "temperature": 22.0,\n            "motion": 0,\n            "light": 300\n        }\n        self.coordinated_devices = {}  # Track other devices\n\n    def on_connect(self, client, userdata, flags, rc):\n        if rc == 0:\n            print(f"Device {self.device_id} connected to MQTT broker")\n            self.connected = True\n\n            # Subscribe to relevant topics\n            client.subscribe("physical_ai/+/+")  # All physical ai topics\n            client.subscribe(f"physical_ai/device/{self.device_id}/command")  # Direct commands\n        else:\n            print(f"Device {self.device_id} failed to connect, return code {rc}")\n            self.connected = False\n\n    def on_message(self, client, userdata, msg):\n        """Handle incoming messages"""\n        try:\n            data = json.loads(msg.payload.decode())\n\n            # Add to received messages\n            self.received_messages.append({\n                "topic": msg.topic,\n                "data": data,\n                "timestamp": time.time()\n            })\n\n            print(f"[{self.device_id}] Received from {msg.topic}: {data}")\n\n            # Process based on topic\n            if "command" in msg.topic:\n                self.handle_command(data)\n            elif "status" in msg.topic:\n                self.handle_status(data)\n            elif "physical_ai/" in msg.topic:\n                self.handle_sensor_data(data)\n\n        except json.JSONDecodeError:\n            print(f"[{self.device_id}] Received non-JSON message: {msg.payload.decode()}")\n\n    def on_disconnect(self, client, userdata, rc):\n        print(f"Device {self.device_id} disconnected from MQTT broker")\n        self.connected = False\n\n    def connect(self):\n        """Connect to the MQTT broker"""\n        try:\n            self.client.connect(self.broker, self.port, 60)\n            self.client.loop_start()\n            # Wait for connection\n            timeout = 5\n            start_time = time.time()\n            while not self.connected and time.time() - start_time < timeout:\n                time.sleep(0.1)\n            return self.connected\n        except Exception as e:\n            print(f"Error connecting device {self.device_id}: {e}")\n            return False\n\n    def handle_command(self, data):\n        """Handle direct commands to this device"""\n        command = data.get("command")\n        if command == "identify":\n            self.publish_device_info()\n        elif command == "sync":\n            self.sync_with_network()\n\n    def handle_status(self, data):\n        """Handle status updates from other devices"""\n        device_id = data.get("device_id")\n        if device_id and device_id != self.device_id:\n            self.coordinated_devices[device_id] = {\n                "status": data.get("status"),\n                "last_seen": data.get("timestamp"),\n                "message": data.get("message", "")\n            }\n\n    def handle_sensor_data(self, data):\n        """Handle sensor data from other devices"""\n        device_id = data.get("device_id")\n        sensor_type = data.get("sensor_type")\n        value = data.get("value")\n\n        if device_id and device_id != self.device_id and sensor_type and value is not None:\n            # Store in coordinated devices\n            if device_id not in self.coordinated_devices:\n                self.coordinated_devices[device_id] = {}\n\n            self.coordinated_devices[device_id][sensor_type] = {\n                "value": value,\n                "timestamp": data.get("timestamp")\n            }\n\n            # Take coordinated action based on combined data\n            self.take_coordinated_action(sensor_type, value, device_id)\n\n    def take_coordinated_action(self, sensor_type, value, source_device):\n        """Take coordinated action based on combined data from multiple devices"""\n        if sensor_type == "temperature":\n            # Check if this is an extreme value that requires coordinated response\n            if value > 30:  # High temperature\n                print(f"[{self.device_id}] Coordinated response: High temperature detected by {source_device}")\n                # Could trigger coordinated cooling across multiple devices\n                self.trigger_coordinated_response("cooling", {"target_device": source_device, "temperature": value})\n\n        elif sensor_type == "motion":\n            if value == 1:  # Motion detected\n                print(f"[{self.device_id}] Coordinated response: Motion detected by {source_device}")\n                # Could trigger coordinated lighting across multiple devices\n                self.trigger_coordinated_response("lighting", {"target_area": source_device})\n\n    def trigger_coordinated_response(self, action_type, params):\n        """Trigger a coordinated response across the network"""\n        command = {\n            "command": "coordinated_action",\n            "action_type": action_type,\n            "params": params,\n            "originator": self.device_id,\n            "timestamp": datetime.now().isoformat()\n        }\n\n        topic = "physical_ai/network/action"\n        self.client.publish(topic, json.dumps(command))\n        print(f"[{self.device_id}] Published coordinated action: {command}")\n\n    def publish_sensor_data(self, sensor_type, value):\n        """Publish sensor data to the network"""\n        if not self.connected:\n            return\n\n        data = {\n            "sensor_type": sensor_type,\n            "value": value,\n            "timestamp": datetime.now().isoformat(),\n            "device_id": self.device_id,\n            "location": f"area_{random.randint(1, 5)}"  # Simulate different locations\n        }\n\n        topic = f"physical_ai/{sensor_type}"\n        self.client.publish(topic, json.dumps(data))\n\n    def publish_device_info(self):\n        """Publish device information"""\n        info = {\n            "device_id": self.device_id,\n            "capabilities": ["temperature", "motion", "light"],\n            "location": f"area_{random.randint(1, 5)}",\n            "timestamp": datetime.now().isoformat()\n        }\n\n        topic = f"physical_ai/device/{self.device_id}/info"\n        self.client.publish(topic, json.dumps(info))\n\n    def sync_with_network(self):\n        """Request synchronization with the network"""\n        sync_request = {\n            "request": "sync",\n            "device_id": self.device_id,\n            "timestamp": datetime.now().isoformat()\n        }\n\n        topic = "physical_ai/network/sync"\n        self.client.publish(topic, json.dumps(sync_request))\n\ndef run_networked_ai_demo():\n    """Run a demonstration of networked Physical AI systems"""\n    print("Networked Physical AI Systems Demo")\n    print("==================================")\n    print("This example demonstrates multiple Physical AI systems communicating")\n    print("and coordinating their actions through MQTT messaging.\\n")\n\n    # Create multiple networked devices\n    devices = []\n    for i in range(3):\n        device = NetworkedPhysicalAI(f"device_{i+1}")\n        devices.append(device)\n\n    # Connect all devices\n    for device in devices:\n        if device.connect():\n            print(f"Connected {device.device_id}")\n        else:\n            print(f"Failed to connect {device.device_id}")\n\n    print(f"\\nStarting simulation with {len(devices)} networked devices...")\n\n    # Simulate sensor readings and network activity\n    for cycle in range(10):\n        print(f"\\n--- Cycle {cycle+1} ---")\n\n        for device in devices:\n            # Simulate sensor readings\n            temp_reading = 20 + random.uniform(-3, 5)\n            motion_reading = 1 if random.random() > 0.7 else 0\n            light_reading = 200 + random.uniform(-50, 100)\n\n            # Publish sensor data\n            device.publish_sensor_data("temperature", round(temp_reading, 2))\n            device.publish_sensor_data("motion", motion_reading)\n            device.publish_sensor_data("light", round(light_reading, 2))\n\n            time.sleep(0.1)  # Small delay between publications\n\n        # Print network status\n        print(f"Network status: {len(devices[0].coordinated_devices)} other devices seen")\n\n        # Show recent messages for first device\n        recent_msgs = devices[0].received_messages[-3:]  # Last 3 messages\n        if recent_msgs:\n            print("Recent network activity:")\n            for msg in recent_msgs:\n                print(f"  {msg[\'topic\']}: {msg[\'data\']}")\n\n        time.sleep(2)  # Wait between cycles\n\n    # Print final summary\n    print(f"\\nFinal network status:")\n    for device in devices:\n        print(f"- {device.device_id}: {len(device.coordinated_devices)} other devices known")\n        print(f"  Messages received: {len(device.received_messages)}")\n\nif __name__ == "__main__":\n    run_networked_ai_demo()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"network-fallback-and-redundancy",children:"Network Fallback and Redundancy"}),"\n",(0,s.jsx)(n.p,{children:"When designing networked Physical AI systems, it's important to implement fallback mechanisms for when network communication fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class NetworkWithFallback:\n    """\n    A Physical AI system with network fallback capabilities\n    """\n    def __init__(self, device_id, broker="localhost", port=1883):\n        self.device_id = device_id\n        self.main_broker = broker\n        self.main_port = port\n        self.fallback_brokers = [("backup-server", 1883), ("cloud-mqtt", 1884)]\n\n        self.primary_client = mqtt.Client(f"{device_id}_primary")\n        self.connected = False\n        self.network_status = "primary"\n        self.fallback_active = False\n\n        # Local data storage for offline operation\n        self.local_data_buffer = []\n        self.local_decision_cache = {}\n\n    def connect_with_fallback(self):\n        """Attempt to connect with fallback options"""\n        # Try primary connection\n        if self._attempt_connection(self.main_broker, self.main_port):\n            self.network_status = "primary"\n            self.fallback_active = False\n            return True\n\n        # Try fallback connections\n        for fallback_broker, fallback_port in self.fallback_brokers:\n            if self._attempt_connection(fallback_broker, fallback_port):\n                self.network_status = f"fallback_{fallback_broker}"\n                self.fallback_active = True\n                print(f"Using fallback connection to {fallback_broker}:{fallback_port}")\n                return True\n\n        # If all connections fail, operate in offline mode\n        self.network_status = "offline"\n        self.fallback_active = True\n        print("Operating in offline mode - using local data and decisions")\n        return False\n\n    def _attempt_connection(self, broker, port):\n        """Attempt to connect to a specific broker"""\n        try:\n            self.primary_client.connect(broker, port, 60)\n            self.primary_client.loop_start()\n            # Verify connection\n            time.sleep(0.5)\n            return True\n        except Exception as e:\n            print(f"Failed to connect to {broker}:{port} - {e}")\n            return False\n\n    def publish_with_buffering(self, topic, data):\n        """Publish data with buffering for offline operation"""\n        if self.network_status == "offline":\n            # Buffer data for later transmission\n            self.local_data_buffer.append({\n                "topic": topic,\n                "data": data,\n                "timestamp": time.time()\n            })\n            print(f"Buffered message for offline transmission: {topic}")\n            return False\n        else:\n            # Publish normally\n            result = self.primary_client.publish(topic, json.dumps(data))\n            return result.rc == 0\n\n    def sync_buffered_data(self):\n        """Sync buffered data when network becomes available"""\n        if self.network_status != "offline" and self.local_data_buffer:\n            print(f"Syncing {len(self.local_data_buffer)} buffered messages...")\n            successful_syncs = 0\n\n            for buffered_item in self.local_data_buffer[:]:  # Copy list to iterate safely\n                result = self.primary_client.publish(buffered_item["topic"],\n                                                   json.dumps(buffered_item["data"]))\n                if result.rc == 0:\n                    self.local_data_buffer.remove(buffered_item)\n                    successful_syncs += 1\n\n            print(f"Synced {successful_syncs} messages, {len(self.local_data_buffer)} remain")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"safety-considerations-for-networked-ai",children:"Safety Considerations for Networked AI"}),"\n",(0,s.jsx)(n.p,{children:"When implementing networked Physical AI systems, safety is crucial:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Isolation"}),": Use separate networks for critical systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Authentication"}),": Implement device authentication to prevent unauthorized access"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encryption"}),": Encrypt communications for sensitive data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rate Limiting"}),": Prevent network flooding that could overwhelm systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fail-Safe Defaults"}),": Ensure systems default to safe states when network fails"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Network Topology"}),": Design different network topologies (star, mesh, hybrid) for Physical AI systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Leader Election"}),": Implement a leader election algorithm for distributed decision making"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Security Enhancement"}),": Add authentication and encryption to the communication protocol"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Create a system that can handle hundreds of networked devices efficiently"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"In this lesson, we explored networked Physical AI systems that can communicate and coordinate with each other. We implemented MQTT-based communication protocols, demonstrated networked sensor coordination, and discussed fallback mechanisms for network failures."}),"\n",(0,s.jsx)(n.p,{children:"Networked Physical AI systems enable distributed intelligence and coordinated actions across multiple devices, opening up possibilities for complex, large-scale Physical AI applications. Proper safety considerations and fallback mechanisms are essential for reliable operation."}),"\n",(0,s.jsx)(n.p,{children:"The concepts learned in this chapter complete the advanced Physical AI systems curriculum, providing a solid foundation for developing sophisticated Physical AI applications that combine sensor fusion, advanced control, and networked coordination."})]})}function f(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);