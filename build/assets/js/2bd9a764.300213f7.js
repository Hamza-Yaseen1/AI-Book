"use strict";(globalThis.webpackChunkphysical_ai=globalThis.webpackChunkphysical_ai||[]).push([[5900],{8453:(n,i,e)=>{e.d(i,{R:()=>s,x:()=>l});var o=e(6540);const a={},t=o.createContext(a);function s(n){const i=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function l(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),o.createElement(t.Provider,{value:i},n.children)}},9811:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"ch04-physical-ai-applications/ch04-lesson02/index","title":"Lesson 2: Autonomous Navigation","description":"Introduction to Autonomous Navigation","source":"@site/docs/ch04-physical-ai-applications/ch04-lesson02/index.md","sourceDirName":"ch04-physical-ai-applications/ch04-lesson02","slug":"/ch04-physical-ai-applications/ch04-lesson02/","permalink":"/docs/ch04-physical-ai-applications/ch04-lesson02/","draft":false,"unlisted":false,"editUrl":"https://github.com/hamza-11/physical-ai/tree/main/docs/ch04-physical-ai-applications/ch04-lesson02/index.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 1: Smart Home Automation","permalink":"/docs/ch04-physical-ai-applications/ch04-lesson01/"},"next":{"title":"Lesson 3: Industrial Quality Control","permalink":"/docs/ch04-physical-ai-applications/ch04-lesson03/"}}');var a=e(4848),t=e(8453);const s={sidebar_position:2},l="Lesson 2: Autonomous Navigation",r={},c=[{value:"Introduction to Autonomous Navigation",id:"introduction-to-autonomous-navigation",level:2},{value:"SLAM Algorithms",id:"slam-algorithms",level:2},{value:"Key SLAM Approaches:",id:"key-slam-approaches",level:3},{value:"Implementation Considerations:",id:"implementation-considerations",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"A* Algorithm:",id:"a-algorithm",level:3},{value:"Key Features:",id:"key-features",level:4},{value:"RRT (Rapidly-exploring Random Trees):",id:"rrt-rapidly-exploring-random-trees",level:3},{value:"Key Features:",id:"key-features-1",level:4},{value:"ROS Framework Integration",id:"ros-framework-integration",level:2},{value:"Navigation Stack Components:",id:"navigation-stack-components",level:3},{value:"Robot Implementation:",id:"robot-implementation",level:3},{value:"Practical Exercise",id:"practical-exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"lesson-2-autonomous-navigation",children:"Lesson 2: Autonomous Navigation"})}),"\n",(0,a.jsx)(i.h2,{id:"introduction-to-autonomous-navigation",children:"Introduction to Autonomous Navigation"}),"\n",(0,a.jsx)(i.p,{children:"Autonomous navigation is a fundamental capability for mobile robots and represents a complex integration of multiple AI technologies. This lesson covers the core technologies including Simultaneous Localization and Mapping (SLAM), path planning algorithms (A* and RRT), and the Robot Operating System (ROS) framework for implementing navigation systems."}),"\n",(0,a.jsx)(i.h2,{id:"slam-algorithms",children:"SLAM Algorithms"}),"\n",(0,a.jsx)(i.p,{children:"Simultaneous Localization and Mapping (SLAM) algorithms enable robots to map and navigate unknown environments by simultaneously building a map of the environment and determining the robot's location within that map."}),"\n",(0,a.jsx)(i.h3,{id:"key-slam-approaches",children:"Key SLAM Approaches:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Visual SLAM using cameras"}),"\n",(0,a.jsx)(i.li,{children:"LiDAR-based SLAM for precision mapping"}),"\n",(0,a.jsx)(i.li,{children:"Sensor fusion techniques combining multiple modalities"}),"\n",(0,a.jsx)(i.li,{children:"Loop closure detection for map consistency"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"implementation-considerations",children:"Implementation Considerations:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Real-time processing requirements"}),"\n",(0,a.jsx)(i.li,{children:"Computational efficiency on embedded systems"}),"\n",(0,a.jsx)(i.li,{children:"Robustness to sensor noise and failures"}),"\n",(0,a.jsx)(i.li,{children:"Scalability for large environments"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,a.jsx)(i.p,{children:"Path planning algorithms compute optimal or feasible paths for robots to navigate from a start to a goal location while avoiding obstacles and considering robot dynamics."}),"\n",(0,a.jsx)(i.h3,{id:"a-algorithm",children:"A* Algorithm:"}),"\n",(0,a.jsx)(i.p,{children:"A* is a graph traversal algorithm that uses heuristics to find the shortest path in weighted graphs. It's widely used in grid-based navigation systems."}),"\n",(0,a.jsx)(i.h4,{id:"key-features",children:"Key Features:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Optimal path guarantee when admissible heuristic is used"}),"\n",(0,a.jsx)(i.li,{children:"Complete (will find a path if one exists)"}),"\n",(0,a.jsx)(i.li,{children:"Can be adapted for various cost functions"}),"\n",(0,a.jsx)(i.li,{children:"Performance depends on heuristic quality"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"rrt-rapidly-exploring-random-trees",children:"RRT (Rapidly-exploring Random Trees):"}),"\n",(0,a.jsx)(i.p,{children:"RRT is a sampling-based algorithm that builds a tree of possible paths by randomly exploring the configuration space. It's particularly effective in high-dimensional spaces with complex obstacles."}),"\n",(0,a.jsx)(i.h4,{id:"key-features-1",children:"Key Features:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Probabilistically complete"}),"\n",(0,a.jsx)(i.li,{children:"Effective in high-dimensional spaces"}),"\n",(0,a.jsx)(i.li,{children:"Can handle kinodynamic constraints"}),"\n",(0,a.jsx)(i.li,{children:"Anytime algorithm (can be stopped early for approximate solution)"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"ros-framework-integration",children:"ROS Framework Integration"}),"\n",(0,a.jsx)(i.p,{children:"The Robot Operating System (ROS) provides a flexible framework for developing robot applications, including navigation-specific packages and tools."}),"\n",(0,a.jsx)(i.h3,{id:"navigation-stack-components",children:"Navigation Stack Components:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"AMCL (Adaptive Monte Carlo Localization)"}),"\n",(0,a.jsx)(i.li,{children:"Costmap_2d for obstacle representation"}),"\n",(0,a.jsx)(i.li,{children:"Move_base for path planning and execution"}),"\n",(0,a.jsx)(i.li,{children:"TF (Transform Library) for coordinate management"}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"robot-implementation",children:"Robot Implementation:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Sensor integration and calibration"}),"\n",(0,a.jsx)(i.li,{children:"Control interface development"}),"\n",(0,a.jsx)(i.li,{children:"Safety and emergency stop systems"}),"\n",(0,a.jsx)(i.li,{children:"Simulation and testing environments"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"practical-exercise",children:"Practical Exercise"}),"\n",(0,a.jsx)(i.p,{children:"Implement a complete navigation system for a mobile robot that can map an unknown environment using SLAM, plan paths using A* or RRT, and execute navigation using ROS. The system should handle dynamic obstacles and adapt to changing environments."}),"\n",(0,a.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(i.p,{children:"This lesson covered the core technologies of autonomous navigation: SLAM algorithms for mapping and localization, A* and RRT for path planning, and ROS for system integration. These technologies form the foundation for mobile robot navigation in both indoor and outdoor environments."})]})}function h(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,a.jsx)(i,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);